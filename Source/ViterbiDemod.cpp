#include "../Include/ViterbiDemod.h"
#include "../Include/WtsCalc.h"
#include "../Include/Sym2Bit.h"
#include <algorithm>
#include <iostream>

using namespace std;

ViterbiDemodulator::ViterbiDemodulator( const SignalParams& sp, int TBLen, bool debug ):
	TBLen( TBLen ), M( sp.M ), L( sp.L ), log2M( sp.log2M ), type( sp.type ), debug( debug ),
	ML( sp.ML ), ML1( sp.ML1 ), ML2( sp.ML2 ), Nt( sp.Nt ), N( sp.N ), NBits( sp.NBits ),
	constType( sp.constType )
{
	NewCumWts.resize(ML1);
	OldCumWts.resize(ML1);


	PrevSts.resize(TBLen);
	for (auto &p : PrevSts)     p.resize(sp.ML1);

	wtsCalc = make_shared< WtsCalc >( sp );
	conv    = make_shared< Sym2Bit >( sp  );
}

ViterbiDemodulator::~ViterbiDemodulator()
{

}

void ViterbiDemodulator::process(const DMatrix& RefSigsR,const DMatrix& RefSigsI, const DMatrix& SigR, const DMatrix& SigI,
	DVector& OutLLR, int SigsShift, int BitNumShift)
{
	int k, k1, n, m, p;

	int CurSt, PrevSt, MaxSt = ML1;

	// Переменная для хранения номера опорного сигнала (reference signal number)
	int RefSigNum;

	// Переменная для хранения текущего минимального значения при поиске минимума в разных случаях (minimum)
	double Min;
	// Временная переменная (buffer)
	double Buf;

	// Инициализация значений NewCumWts и OldCumWts
	fill(OldCumWts.begin(), OldCumWts.end(), MInf);

	fill(NewCumWts.begin(), NewCumWts.end(), 0);

	OldCumWts.at(0) = 0;

	// Переменная для хранения номера текущего столбца в PrevSts (column number)
	int32_t PrevStsColNum = TBLen - 2;

	// Переменная для хранения оценки значения модуляционного символа (out
	// symbol)
	int OutSym;
	// Переменная - число бит на которые надо сдвинуть значение текущего
	// состояния чтобы получить OutSym
	int32_t OutSymBitShift = log2M * ( L - 2 );

	// Переменная для хранения номера бита, который надо записать следущим (bit number)
	int BitNum = BitNumShift;
	// Переменная значения сдвига позиции BitNum при обратном проходе
	int BitNumRevShift;

	// Переменные для хранения количества требуемых для обработки ТИ (X),
	// числа необходимых для пропуска (Z) и демодулирования (Y) символов
	// при последнем обратном проходе по PrevSts (дополнительные пояснения
	// будут даны ниже)
	int X, Y, Z;

	if( debug ) cout << "First step of processing" << endl;
	// 1. На первых T-1 ТИ делаются только ВВМП без вынесения решений о
	// символах
	for (k = 0, k1 = SigsShift; k < TBLen - 1; k++, k1++) { // k - номер
															// текущего ТИ
															// Вычислим веса всех переходов
		wtsCalc->CalculateWts( RefSigsR, RefSigsI, SigR.at(k1), SigI.at(k1), k );
		// Определим выжившие пути и метрики этих путей
		wtsCalc->CalculatePrevStAndCumWts( NewCumWts, OldCumWts, PrevSts.at(k));
		// Подготовимся к следующей итерации
//		swap(OldCumWts, NewCumWts);
	}


	if( debug ) cout << "Second step of processing" << endl;
	// 2. На X ТИ делается сначала вынесение решения (одно решение за один
	// полный обратный проход), потом ВВМП на одном ТИ. Внимание, если
	// выбрано максимальное значение TBLen = NSyms+L-1, то цикла в части 2
	// не будет вовсе!
	X = ( TBLen <= L ) ? N - 1 : N + L - 1 - TBLen;
	if( debug ) cout << "X = " << X << " N " << N << " L " << L <<" TB" << TBLen<< endl;


	for (k = TBLen - 1, k1 = k + SigsShift; k < TBLen - 1 + X; ++k, ++k1) {
		// k - номер текущего ТИ
		// Вычислим веса всех переходов
		wtsCalc->CalculateWts( RefSigsR, RefSigsI, SigR.at(k1), SigI.at(k1), k );

		// Определим выжившие пути и метрики этих путей
	 
		PrevStsColNum = ( PrevStsColNum + 1 ) % TBLen;

		wtsCalc->CalculatePrevStAndCumWts( NewCumWts, OldCumWts, PrevSts.at(PrevStsColNum) );
		// Подготовимся к следующей итерации
		swap(OldCumWts, NewCumWts);
		// Определение значения очередного символа обратным проходом по
		// PrevSts.
		// Если мы находимся в конце "решётки" сигнала, то возможны
		// не все состояния, каждый терминационный символ уменьшает
		// количество возможных состояний в M раз. Учёт этого
		// обстоятельства может оказать влияние только на значения
		// максимум L-2 символов и то, если не выбрано
		// максимальное значение TBLen. Так что, при желании
		// максимально увеличить скорость выполнения фукнции, можно
		// отключить (закомментировать) выполнение этих трёх строк.
		if (k >= N ) 			MaxSt >>= log2M; // деление на M

		// Сначала определим путь с лучшей метрикой на текущем шаге
		Min = MInf;

 		auto mi = min_element( OldCumWts.begin(), OldCumWts.begin() + MaxSt,
			[ ](double left, double right) { return ( left < right ); });
		Min = *mi;
		PrevSt = distance( OldCumWts.begin(), mi );

		// Сделаем TBLen-1 обратных переходов по PrevSts из
		// состояния с номером PrevSt на текущем шаге
		m = PrevStsColNum;
		for (n = 0; n < TBLen - 1; n++) {
			PrevSt = PrevSts[ m ][ PrevSt ];
			if (--m== -1)			m = TBLen - 1;
		}
		// Преобразуем номер состояния в номер символа
		OutSym = ( PrevSt >> OutSymBitShift );

		// Преобразуем номер символа в значения бит и вставим их в
		// позиции, начиная с BitNum
		conv->convert( OutLLR, OutSym);
	}
	if( debug ) cout << "Third step of processing " << endl;
	// 3. Делается ВВМП на одном ТИ и вынесение решения об Y символах за
	// один обратный проход. Если T <= L то Y = 1, иначе Y = T-(L-1).
	// Дополнительно к Y вычислим количество холостых обратных шагов
	// Z = T - Y.
	Y = (TBLen <= L) ? 1 : TBLen - ( L - 1 );
	Z = TBLen - Y;

	// ВВМП на одном ТИ
	// Вычислим веса всех переходов (k имеет нужное значение!)
	wtsCalc->CalculateWts( RefSigsR, RefSigsI,  SigR.at(k1), SigI.at(k1), k );

	// Определим выжившие пути и метрики этих путей
	PrevStsColNum = ( PrevStsColNum + 1 ) % TBLen; 
	wtsCalc->CalculatePrevStAndCumWts( NewCumWts, OldCumWts, PrevSts.at(PrevStsColNum));

	// Вынесение решения об Y символах
	// Cначала надо сделать Z холостых шагов
	PrevSt = 0; // Мы точно знаем из какого состояния начинать
	for (k = 0; k < Z; ++k) {
		// Один шаг назад по "решётке" сигнала
		PrevSt = PrevSts.at(PrevStsColNum).at(PrevSt);
		PrevStsColNum--;
		if (PrevStsColNum == -1)
			PrevStsColNum = TBLen - 1;
	}


	// Продолжим движение назад по PrevSts, но уже с демодуляцией
	// Установим BitNum в позицию первого бита последнего
	// символа
	BitNum = NBits - log2M + BitNumShift;
	// После определения значения последнего бита текущего
	// символа надо будет сдвигать BitNum на 2*log2M влево,
	// т.е. на позицию первого бита предыдущего символа
	BitNumRevShift = ( log2M << 1 );

	if( debug ) cout << "Y = " << Y <<" PrevSt " << PrevSt << endl;
	for (k = 0; k < Y; ++k) {
		// Преобразуем номер состояния в номер символа
		OutSym = ( PrevSt >> OutSymBitShift );

		// Преобразуем номер символа в значения бит и вставим
		// их в позиции, начиная с BitNum
		conv->convert( OutLLR, OutSym);
		BitNum -= BitNumRevShift;

		// Один шаг назад по "решётке" сигнала
		PrevSt = PrevSts.at(PrevStsColNum).at(PrevSt);
		PrevStsColNum--;
		if (PrevStsColNum == -1)
			PrevStsColNum = TBLen - 1;
	}
}

#if 0
///////////////////////////////////////////////////////////////////////////
// ОСНОВНАЯ ОБРАБОТКА /////////////////////////////////////////////////////
// TBLen численно равен количеству тактовых интервалов (ТИ), после
// обработки которых выносится решение о первом символе; далее с
// каждым новым ТИ выносится решение о новом символе. Таким образом,
// демодулятор имеет память о путях на TBLen ТИ (см. PrevSts). В общем
// случае в начале демодуляции каждый символ получается путём одного
// полного обратного прохода по этой памяти по лучшему на текущий
// момент пути. Однако в конце демодуляции с учётом терминации за один
// обратный проход по памяти демодулятора получаются сразу несколько
// символов. Возможны разные ситуации в зависимости от значения TBLen,
// которое само по себе ограничено количеством тактовых интервалов и,
// следовательно, 1 <= TBLen <= NSyms+L-1. (Далее в тексте и на
// картинках для упрощения записи TBLen = T; NSyms = N.)
//
// 1 <= T <= L (далее "Вариант 1"):
//   В этой ситуации даже не потребуется обрабатывать последние (L-T)
//   ТИ. Все N символов получаются поточно (т.е. с каждым новым ТИ,
//   начиная с ТИ №T, выносится решение об одном символе). Иллюстрации
//   тактовых интервалов, используемых для получения значения
//   последнего символа будут такими:
//     T = 1 (не обрабатываются L-1 ТИ):
//         |<-N ТИ---->|<-L-1 ТИ>|
//       --|-| ... |-|-|-| ... |-|-->t
//           T ТИ -> | |r
//   
//     1 < T < L (не обрабатываются L-T ТИ):  
//         |<-N ТИ---->|<-L-1 ТИ---------->|
//       --|-| ... |-|-|-| ... |-|-| ... |-|-->t
//                   |<-T ТИ---->|
//
//     T = L (не обрабатываются 0 ТИ):  
//         |<-N ТИ---->|<-L-1 ТИ-->|
//       --|-| ... |-|-|-| ... |-|-|-->t
//                   |<-T ТИ------>|
//
// L+1 <= T <= N+L-1 (далее "Вариант 2"):
//   В этой ситуации первые (N+L-1)-T символов получаются поточно (т.е.
//   с каждым новым ТИ, начиная с ТИ №T, выносится решение об одном
//   символе). Оставшиеся T-(L-1) символов получаются из памяти
//   демодулятора за один обратный проход (первые L-1 символов в
//   обратном проходе отбрасываются, так как они терминационные).
//     T = L+1 (первые N-2 символов обрабатываются поточно, последние
//       два символа получаются из одного обратного прохода по памяти
//       демодулятора, при этом первые L-1 символов отбрасываются, так
//       как они терминационные):
//         |<-N ТИ------>|<-L-1 ТИ>|
//       --|-| ... |-|-|-|-| ... |-|-->t
//                   |<-T ТИ------>|
//
//     L+1 < T < N+L-1 (первые (N+L-1)-T символов получаются поточно, а
//       оставшиеся T-(L-1) из одного обратного прохода):
//         |<-N ТИ------------>|<-L-1 ТИ>|
//       --|-| ... |-|-| ... |-|-| ... |-|-->t
//                   |<-T ТИ------------>|
//    
//     T = N+L-1 (все N символов получаются из обратного прохода):
//         |<-N ТИ-->|<-L-1 ТИ>|
//       --|-| ... |-|-| ... |-|-->t
//         |<-T ТИ------------>|
//    
// Чтобы объединить оба варианта в одном коде, будем делать так.
// 1. На первых T-1 ТИ делаются только вычисления весов и метрик путей
//    (ВВМП) без вынесения решений о символах.
// 2. На X ТИ делается сначала ВВМП на одном ТИ, потом вынесение
//    решения (одно решение за один полный обратный проход). Если
//    T <= L то X = N-1, иначе X = N+L-1-T.
// 3. Делается ВВМП на одном ТИ и вынесение решения об Y символах за
//    один обратный проход. Если T <= L то Y = 1, иначе Y = T-(L-1).
//
// Проверим:
// Если T <= L: производится обработка (T-1)+(N-1)+1 = N+T-1 ТИ,
//              выносится решение о (N-1)+1 = N символах.
// иначе:       производится обработка (T-1)+(N+L-1-T)+1 = N+L-1 ТИ,
//              выносится решение о (N+L-1-T)+(T-(L-1)) = N символах.
//
// т.е. всё верно: в обоих случаях выносится решение о N символах, в
// первом случае обрабатываются N+T-1 ТИ, во втором - все N+L-1 ТИ.
#endif
